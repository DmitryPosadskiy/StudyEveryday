#### Многопоточность

**read-modify-write** - проблема работы с общим для нескольких потоков ресурсом. Для случая
двух потоков A и B.
* поток A читает переменную V
* переключение потоков
* поток B читает переменную V
* поток B модифицирует переменной V в памяти в V'
* поток B записывает модифицированное значение V' в переменную V
* переключение потоков
* поток A модифицирует переменную V в V''
* поток A сохраняет значение V'' в переменную V.

В результате, для параллельной программы значение переменной будет равно V'', а для последовательной
суперпозиции применения V' к V'' - значению V'''.

Для решения этой проблемы можно использовать в качестве переменной Atomic тип данных (Long, 
Integer и другие).

**Atomic типы** - типы данных из библиотеки java.util.concurrent, которые поддерживают атомарное
выполнение некоторых операций. Реализуется это на нативном уровне.
Например, `public native long getLongVolatile(Object o, long offset);`

Однако, если переменных несколько, то такое решение не поможет. Правильное выполнение программы,
которая вызывает хоть и атомарные методы, но не синхронно, не гарантирована. Решением здесь будет
использование метода или блока *synchronized*.

**synchronized** - ключевое слово для объявления [блока кода](#synchronized-block)
или [метода](#synchronized-method), код в котором должен выполняться синхронно. Блокировка
приобретается для потока, а не для вызова. Это реализовано с помощью счетчика захватов и имени
потока-держателя. Когда количество захватов объекта равно нулю и есть желающий, JVM увеличивает
счетчик захватов и записывает владельца. Если в процессе выполнения когда внутри синхронного блока
процессу нужно снова зайти в тот же самый синхронный блок (рекурсия?), счетчик снова увеличивается.


#### Примеры
##### synchronized-block
```java
synchronized(mutex) {
    // синхронный код
}
```

##### synchronized-method
```java
synchronized void syncMethod() {
    // синхронный код
}
```