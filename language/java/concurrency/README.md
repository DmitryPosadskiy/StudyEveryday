#### Многопоточность

**read-modify-write** - проблема работы с общим для нескольких потоков ресурсом. Для случая
двух потоков A и B.
* поток A читает переменную V
* переключение потоков
* поток B читает переменную V
* поток B модифицирует переменной V в памяти в V'
* поток B записывает модифицированное значение V' в переменную V
* переключение потоков
* поток A модифицирует переменную V в V''
* поток A сохраняет значение V'' в переменную V.

В результате, для параллельной программы значение переменной будет равно V'', а для последовательной
суперпозиции применения V' к V'' - значению V'''.

Для решения этой проблемы можно использовать в качестве переменной Atomic тип данных (Long, 
Integer и другие).

**Atomic типы** - типы данных из библиотеки java.util.concurrent, которые поддерживают атомарное
выполнение некоторых операций. Реализуется это на нативном уровне.
Например, `public native long getLongVolatile(Object o, long offset);`

Однако, если переменных несколько, то такое решение не поможет. Правильное выполнение программы,
которая вызывает хоть и атомарные методы, но не синхронно, не гарантирована. Решением здесь будет
использование метода или блока *synchronized*.

**synchronized** - ключевое слово для объявления [блока кода](#synchronized-block)
или [метода](#synchronized-method), код в котором должен выполняться синхронно. Блокировка
приобретается для потока, а не для вызова. Это реализовано с помощью счетчика захватов и имени
потока-держателя. Когда количество захватов объекта равно нулю и есть желающий, JVM увеличивает
счетчик захватов и записывает владельца. Если в процессе выполнения когда внутри синхронного блока
процессу нужно снова зайти в тот же самый синхронный блок (рекурсия?), счетчик снова увеличивается.

#### Deadlock
Два потока блокируют по одному объекту и начинают ожидать освобождение другого, но этого не
произойдет. [Пример](#deadlock)

#### Livelock
Два потока нивелируют работу друг друга. Причем, действия одного потока не дают другому
завершиться. [Пример](#livelock)

#### Starvation
Поток редко получает процессорное время в связи с наличием "жадного" потока.

#### Примеры
##### synchronized-block
```java
synchronized(mutex) {
    // синхронный код
}
```

##### synchronized-method
```java
synchronized void syncMethod() {
    // синхронный код
}
```

##### deadlock
```java
Object a = new Object;
Object b = new Object;

// in thread one
synchronized(a) {
	synchronized(b) {}
}

// in thread two
synchronized(b) {
	synchronized(a) {}
}
```

##### livelock
```java
int x = 0;

// in thread one
while (x < 100) {
	sendPrintRequest();
	++x;
}

// in thread two
while (x >= 0) {
	clearRequest();
	--x;
}
```