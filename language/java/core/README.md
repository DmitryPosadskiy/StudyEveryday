#### Инициализация
Способы инициализации поля класса по порядку вызова:

* *Инициализация в super-class*
* *Инициализация при объявлении*
`String name = "John"`
* *Блок статической инициализации*
`static { name = "Garry" }`
* *Блок инициализации*
`{ this.name = "Mary" }`
* *Конструктор* 
`public Person() { this.name = "Alex" }`

Переменные экземпляра и класса инициализируются по умолчанию. Локальные переменные - нет.

В классе может находиться метод с названием класса. Он должен возвращать значение или быть void.

Статический инициализатор обычно используется, чтобы задать значения статическим полям, когда на 
это требуется больше одной строки. Например, для инициализации ArrayList значениями. В таком случае
принято выносить всю статическую инициализацию в одно место для удобства чтения.

Конструктор по-умолчанию будет сгенерирован, если в классе отсутствует хотя бы один конструктор.

#### Примитивные типы

| Тип | Размер | Значение
| --- | --- | ---
| byte | 8 бит | 0
| short | 16 бит | 0
| integer | 32 бита | 0
| long | 64 бита | 0
| float | 32 бита | 0.0
| double | 64 бита | 0.0
| char | 16 бит | \u0000

Переменные типов int и double можно записывать через "_" для разделения знаков.
`int value = 1_000_000`
`double balance = 2_232.0_0`

#### Импорт

Если классы находятся в одном пакете, то при использовании одного другим импорт *не нужен*.

В файле с классом обязательным является только само объявление.
Строка `package` может отсутствовать, если класс не находится в пакете.
Список импортов также может не присутствовать.

#### Запуск из консоли

`java MyClass parameterOne "parameterTwo"`

#### Сравнение

Нельзя сравнивать разные типы данных с помощью `==`.

#### Коллекции

##### ArrayList
Сравнение через equals двух листов с одинаковыми элементами вернет `true`.

##### VarArg

Если вместо данных передать null, это вызовет NPE.

##### Конвертация
При вызове метода может произойти одинарная конвертация аргумента. Например, int -> Integer или
int -> long. Но Java не пропустит конвертацию порядка два или выше. Например, int -> long -> Long,
как в примере ниже.
```java
public class TooManyConversions { 
    public static void play(Long l) { }
    public static void play(Long... l) { } 
    public static void main(String[] args) {
        play(4); // DOES NOT COMPILE
        play(4L); // calls the Long version 
    }
}
```